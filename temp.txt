#include <WiFi.h>
#include <WiFiClient.h>
#include <WebServer.h>

//Throttle values
#define DAC_VALUE_RUN (255 * 1.8 / 3.3)
#define DAC_VALUE_STOP (255 * 0.8 / 3.3)

//control pins
#define PIN_THOTTLE 25
#define PIN_BRAKES 27
#define PIN_CAR_DIR 26

//steering pins
#define PIN_STEER_DIR 33  // Stepper DIR
#define PIN_STEP 32       // Stepper STEP

//forward normally opened
enum {
  backward = 0,
  forward
};

//brakes off normally opened
enum {
  brakes_on = 0,
  brakes_off
};

//steering
typedef enum {
  st_right = 0,
  st_left
} SteeringDir;

// -------------------------------------------Global Variables------------------------------------
//Steering  variables:
int currentPosition = 0;           // Track current step position
const int maxSteeringSteps = 200;  // Limit to prevent oversteering
int Stepper_PUL_Width = 3000;      // Pulse width in micro sec
SteeringDir dir = st_right;

//brakes variables:
const int braking_time = 100;  //ms

//WIFI variables:
String command = "S";  //String to store app command state.
const char* ssid = "Wifi Car";
const char* password = "12345678";
WebServer server(80);

//-------------------------------------------Setup------------------------------------
void setup() {
  pinMode(PIN_THOTTLE, OUTPUT);
  pinMode(PIN_BRAKES, OUTPUT);
  pinMode(PIN_CAR_DIR, OUTPUT);
  pinMode(PIN_STEER_DIR, OUTPUT);
  pinMode(PIN_STEP, OUTPUT);

  Serial.begin(115200);

  // Connecting WiFi
  WiFi.mode(WIFI_AP);
  WiFi.softAP(ssid, password);

  IPAddress myIP = WiFi.softAPIP();
  Serial.print("AP IP address: ");
  Serial.println(myIP);

  // Starting WEB-server
  server.on("/", HTTP_handleRoot);
  server.onNotFound(HTTP_handleRoot);
  server.begin();
}


//-------------------------------------------Loop------------------------------------
void loop() {
  server.handleClient();
  static String lastCommand = "";
  String newCommand = server.arg("State");

  if (newCommand != "" && newCommand != lastCommand) {
    command = newCommand;
    Serial.print("CMD = ");
    Serial.println(command);
    switch (command[0]) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          Stepper_PUL_Width = (command[0] - '0' + 1) * 1000;
        }
      case 'F':
        {
          goHome();
          goAhead();
          break;
        }
      case 'B':
        {
          goHome();
          goBack();
          break;
        }
      case 'S':
        {
          stopRobot();
          break;
        }

      case 'L':
        {
          dir = st_left;
          while (server.arg("State") == "L") {
            goLeft();
            server.handleClient();
          }
          break;
        }
      case 'R':
        {
          dir = st_right;
          while (server.arg("State") == "R") {
            goRight();
            server.handleClient();
          }
          break;
        }
      case 'I':
        {
          goAhead();
          dir = st_right;
          while (server.arg("State") == "I") {
            goRight();
            server.handleClient();
          }
          break;
        }
      case 'G':
        {
          goAhead();
          dir = st_left;
          while (server.arg("State") == "G") {
            goLeft();
            server.handleClient();
          }
          break;
        }
      case 'J':
        {
          goBack();
          dir = st_right;
          while (server.arg("State") == "J") {
            goRight();
            server.handleClient();
          }
          break;
        }
      case 'H':
        {
          goBack();
          dir = st_left;
          while (server.arg("State") == "H") {
            goLeft();
            server.handleClient();
          }
          break;
        }
    }
    lastCommand = command;
  }
}


//-------------------------------------------APIs------------------------------------
// ====== CORE MOTOR FUNCTIONS ======
void stepMotor(SteeringDir dir) {
  //Set direction
  digitalWrite(PIN_STEER_DIR, dir);
  //move one step
  digitalWrite(PIN_STEP, HIGH);
  delayMicroseconds(Stepper_PUL_Width);
  digitalWrite(PIN_STEP, LOW);
  delayMicroseconds(Stepper_PUL_Width);
}

void goAhead() {
  //Release brakes
  digitalWrite(PIN_BRAKES, brakes_off);
  //Set direction
  digitalWrite(PIN_CAR_DIR, forward);
  //apply throttle
  dacWrite(PIN_THOTTLE, DAC_VALUE_RUN);
}

void goBack() {
  //Release brakes
  digitalWrite(PIN_BRAKES, brakes_off);
  //Set direction
  digitalWrite(PIN_CAR_DIR, backward);
  //apply throttle
  dacWrite(PIN_THOTTLE, DAC_VALUE_RUN);
}

// ====== STEERING ======
void goLeft() {
  if (currentPosition < maxSteeringSteps) {
    stepMotor(st_left);
    currentPosition++;
  }
}

void goRight() {
  if (currentPosition < maxSteeringSteps) {
    stepMotor(st_right);
    currentPosition++;
  }
}

void goHome() {
  //Check if Already at Home
  if (currentPosition == 0) {
    Serial.println("Already at Home");
    return;
  }
  //Reverse direction
  dir = ((dir == st_right) ? st_left : st_right);
  digitalWrite(PIN_STEER_DIR, dir);
  //Move back the current position
  for (int i = 0; i < currentPosition; i++) {
    digitalWrite(PIN_STEP, HIGH);
    delayMicroseconds(Stepper_PUL_Width);
    digitalWrite(PIN_STEP, LOW);
    delayMicroseconds(Stepper_PUL_Width);
  }
  currentPosition = 0;
  Serial.println("Steering centered");
}


// void goAheadRight(){

// }

// void goAheadLeft(){

// }

// void goBackRight(){

// }

// void goBackLeft(){

// }


void stopRobot() {
  //Steering home
  goHome();
  // Release  throttle
  dacWrite(PIN_THOTTLE, DAC_VALUE_STOP);
  //Activate brakes
  digitalWrite(PIN_BRAKES, brakes_on);
  delay(braking_time);
  digitalWrite(PIN_BRAKES, brakes_off);
}

void HTTP_handleRoot(void) {

  // if( server.hasArg("State") ){
  //   Serial.println(server.arg("State"));
  // }

  server.send(200, "text/html", "");
  delay(1);
}